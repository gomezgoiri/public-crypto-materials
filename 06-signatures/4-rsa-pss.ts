/*
 * Implementad RSA PSS.
 *
 * Función de hash: SHA1
 * Función de generación de máscara: mgf1SHA1
 * Tamaño de la salt: 20 bytes
 * Trailer field: 0xbc
 */

import { Buffer } from "node:buffer"
import { powermod, toNumber } from "./utils.ts"
import { randomBytes } from "node:crypto"

const KEY_LENGTH = 2048

async function mgf1SHA1(
  seed: Uint8Array,
  maskLength: number,
): Promise<Uint8Array> {
  const ret = new Uint8Array(maskLength)

  const hLen = 20 // 160 bits, the size of hashes in SHA-1
  for (let i = 0; i < Math.ceil(maskLength / hLen); i++) {
    // Convert counter to 4-byte big-endian
    const counter = new Uint8Array([
      (i >>> 24) & 0xff,
      (i >>> 16) & 0xff,
      (i >>> 8) & 0xff,
      i & 0xff,
    ])

    // Concatenate seed and counter
    const data = new Uint8Array(seed.length + 4)
    data.set(seed)
    data.set(counter, seed.length)

    // Hash the data using SHA-1
    const hashBuffer = await crypto.subtle.digest("SHA-1", data)
    const hash = new Uint8Array(hashBuffer)

    // Copy to result
    const offset = i * hLen
    ret.set(
      hash.slice(0, Math.min(hash.length, maskLength - offset)),
      offset,
    )
  }

  return ret
}

type EmAndSalt = { em: Buffer; salt: Uint8Array }

const SHA1_LIMIT = (2n ** 61n) - 1n

// https://datatracker.ietf.org/doc/html/rfc3447#section-9.1.1
async function encodeEmsaPss(
  message: Buffer,
  proposedSalt?: Buffer,
): Promise<EmAndSalt> {
  const emLen = Math.floor((KEY_LENGTH - 1) / 8)

  if (message.length > SHA1_LIMIT) {
    throw new Error("Message too long")
  }

  // mHash <- hash(m)
  const mHash = null

  // Genera salt aleatorio de sLen si salt es undefined
  const salt = null

  if (emLen < mHash.byteLength + salt.byteLength + 1) {
    throw new Error("Encoding error")
  }

  // m2 <- 0x00..0000 (8 bytes de ceros) || mHash || salt
  // h <- hash(m2)

  // db es un buffer de tamaño: emLen - hLen - 1
  // db <- 00...0 || 0x01 || salt
  // dbMask <- mgf1SHA1(h2, db.length)
  // maskedDB <- db xor dbMask
  // maskedDB[0] <- 0

  // em <- maskedDB || h || 0xbc

  return
}

type SignatureAndSalt = { signature: bigint; salt: Uint8Array }

async function signRSAPSS(
  message: Buffer,
  d: bigint,
  N: bigint,
  proposedSalt?: Buffer,
): Promise<SignatureAndSalt> {
}

async function verifyRSAPSS(
  message: Buffer,
  signature: bigint,
  e: bigint,
  N: bigint,
  salt: Buffer,
): Promise<boolean> {
}

const aliceKeyPair = await crypto.subtle.generateKey(
  {
    name: "RSA-PSS",
    modulusLength: KEY_LENGTH,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" },
  },
  true,
  ["sign", "verify"],
)

const pk = await crypto.subtle.exportKey("jwk", aliceKeyPair.privateKey)
const e = toNumber(Buffer.from(pk.e, "base64"))
const d = toNumber(Buffer.from(pk.d, "base64"))
const N = toNumber(Buffer.from(pk.n, "base64"))

const pt = Buffer.from("super important message to sign", "utf8")

const { signature, salt } = await signRSAPSS(pt, d, N)
console.log("Number generated by signer:", signature)

const ok = await verifyRSAPSS(pt, signature, e, N, salt)
console.log("Is signature valid?", ok)
